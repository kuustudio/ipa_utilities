#!/usr/bin/env ruby

require 'commander/import'
require 'colorize'
require 'ipa_utilities'

HighLine.track_eof = false
Signal.trap("INT") {}

$verbose = false
global_option('--verbose') { $verbose = true }


program :version, IpaVersion::VERSION
program :description, 'A command-line interface for dealing with ipas'

program :help, 'Author', 'Omar Abdelhafith <o.arrabi@me.com>'
program :help, 'Website', 'http://nsomar.com'
program :help_formatter, :compact

default_command :help

command :verify do |c|
  c.syntax = 'ipa_utilities verify ipa_path [...]'
  c.summary = 'Verifies the ipa provision and signature information'

  c.example 'description', 'ipa_utilities verify ipa_path'
  c.option '-c', '--certificate certificate', 'Path of the push notification PEM certificate'
  c.option '-d', '--device UDID', 'UDID of device to check if its included in embedded provision profile'
  c.option '--devices', 'Show all the devices included in the provision profile'

  c.action do |args, options|
    begin
      ipa = IpaParser.new(parse_path(args, "ipa"))

      print_app_bundle(ipa)
      print_provision_profile(ipa.provision_profile)
      verify_certificates(ipa.provision_profile, options.certificate) if options.certificate
      print_provisioned_devices(ipa.provision_profile) if options.devices
      search_udid(ipa.provision_profile, options.device) if options.device

    rescue Exception => err
      say_error err.message
    ensure
      ipa.cleanup
    end
  end
end

command :convert do |c|
  c.syntax = 'ipa_utilities convert p12_path [...]'
  c.summary = 'Convert a p12 to PEM'

  c.example 'description', 'ipa_utilities convert p12_file_path'
  c.option '-o', '--out output_path', 'Out put file for the Pem file'

  c.action do |args, options|

    path = parse_path(args, "p12")
    exit unless path

    output_path = options.out || "~/Desktop/out.pem"

    begin

      puts
      puts "Converting P12 to Pem"
      system "openssl pkcs12 -in #{path} -out #{output_path} -nodes -clcerts"
      puts "Pem saved at " + output_path.green

    ensure

    end
  end
end

command :certificate do |c|
  c.syntax = 'ipa_utilities certificate ipa [...]'
  c.summary = 'fetch the correct push identity from the provided ipa (WIP)'

  c.example 'description', 'ipa_utilities certificate ipa_path (WIP)'

  c.action do |args, options|

    path = parse_path args, "ipa"
    exit unless path

    begin
      ipa = IpaParser.new path

      apns_environment = ipa.provision_profile.production_apns? ? "Production" : "Development"
      identity_name = "Apple #{apns_environment} IOS Push Services: #{ipa.provision_profile.bundle_id}"

      puts "Searching Keychain for identity " + identity_name.green

      identities = `security find-identity -v -p ssl-client`
      if identities.lines.index { |s| s.include?(identity_name) }
        puts "Item found please export it from your keychain".green
      else
        puts "Item couldn't be found in your keychain".red
      end
    ensure
      ipa.cleanup
    end
  end
end

command :resign do |c|
  c.syntax = 'ipa_utilities resign ipa -p new_profile'
  c.summary = 'Resigns the passed ipa to the new passed profile'

  c.example 'description', 'ipa_utilities certificate ipa_path -p profile'
  c.option '-p', '--profile profile_path', 'Path of the provision profile to use'
  c.option '-o', '--out output_path', 'Out put file for the Pem file'

  c.action do |args, options|
    begin
      path = parse_path(args, "ipa")

      unless options.profile
        say_error "pass a profile with -p profile_path"
        exit
      end

      profile = parse_path([options.profile], "provision profile")

      output_path = options.out || "~/Desktop/resigned.ipa"

      ipa = IpaParser.new(path)
      ipa.delete_old_signature

      parser = ipa.provision_parser

      puts "Copying the new provision profile to app bundle"
      system "cp \"#{profile}\" \"Payload/#{ipa.bundle_name}/embedded.mobileprovision\""

      puts "Writing Entitlements.plist"
      File.write "Entitlements.plist", parser.signing_entitlement

      build_name = parser.release_build? ? "Distribution" : "Development"
      system "codesign -s \"iPhone #{build_name}: #{parser.team_name} (#{parser.team_identifier})\" --entitlements Entitlements.plist \"Payload/DummyApp.app\" -f"

      puts
      ipa.zip output_path

    ensure
      ipa.cleanup
    end
  end
end

def parse_path(args, title)
  raise "Path to #{title} is required" if args.nil? || args.empty?
  path = args.first
  raise "Couldn't find #{title} with path #{path}" unless File.exist?(path)

  path
end

def print_app_bundle(ipa)
  puts "______Bundle information______"
  puts "App bundle name: " + ipa.bundle_name.green
  print "Verifying app bundle signature: "
  say ipa.signature_valid? ? "Signature Valid".green : "Signature Not Valid".red + result.red
end

def verify_certificates(provision_profile, apns_certificate_path)
  puts "\n______Checking certificates______"

  apns_certificate = SigningIdentity.new(apns_certificate_path)

  if apns_certificate.apns?
    puts "Certificate Name " + apns_certificate.name.green
    puts "Certificate Environment: " + "#{apns_certificate.environment}".green
    puts "Certificate Bundle ID: " + "#{apns_certificate.bundle_id}".green

    str = apns_certificate.bundle_id == provision_profile.bundle_id ? "Yes".green : "No".red
    puts "Certificate bundleId identical to App bundleId  #{str}"

    same_environment = apns_certificate.production? == provision_profile.production_apns?
    str = same_environment ? "Yes".green : "No".red
    puts "Provided certificate correct for the ipa: #{str}"

    unless same_environment
      puts %{\
The application was build with a provision profile containing aps-environment \
in `#{provision_profile.environment}` environment while the passed certificate environment is set \
to `#{apns_certificate.environment}`\
           \nTo fix this issue either export the correct \
iOS Push `#{apns_certificate.environment}` certificate from keychain or rebuild your app \
with the correct provision profile}.red
    end
  else
    puts "The passed certificate is not an APNS certificate".red
  end
end

def search_udid(provision_profile, device_udid)
  puts "\n______Searching provisioned device______"

  if provision_profile.app_store_build?
    puts "Distribution build do not contain provisioned devices".red
  else
    puts "Embedded provision profile contains " + "#{provision_profile.provisioned_devices.count}".green + " devices"
    puts provision_profile.provisioned_devices.include?(device_udid) ?
             "Device with UDID `#{device_udid}` found".green :
             "Device with UDID `#{device_udid}` not found".red
  end
end

def print_provisioned_devices(provision_profile)
  puts "\n______Provisioned devices______"

  puts "Embedded provision profile contains " + "#{provision_profile.provisioned_devices.count}".green + " devices"
  puts provision_profile.provisioned_devices
end

def print_provision_profile(provision_profile)
  puts "\n______Provision profile information______"
  puts "App bundle id: " + provision_profile.bundle_id.green
  puts "Team name: " + provision_profile.team_name.green
  puts "Profile display name: " + provision_profile.display_name.green

  puts "\n______Build environments______"
  puts "App environment: " + provision_profile.build_environment.green
  puts "APNS environment: " + provision_profile.apns_environment.green

  str = provision_profile.apns_and_app_same_environment? ? "Yes".green : "No".red
  puts "App and APNS on same environment: " + str

  puts "APNS connection gateway: " + provision_profile.apns_gateway.green
  unless provision_profile.apns_and_app_same_environment?
    puts %{\
The application was build with get-task-allow set to `#{provision_profile.task_allow?}` while \
the aps-environment is set to `#{provision_profile.apns_environment}`, To fix this issue regenerated \
the provision profile from apple developer then rebuild the app using it}.red
  end
end